---
title: "Ayudantía 1: Muestreo y Analisis Descriptivo"
author: "Diego Bernal Soto: diego.bernals@usm.cl"
date: "Semestre 02-2023"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    collapsed: true
    smooth_scroll: true
    theme: journal
    highlight: kate
    df_print: paged
    code_folding: show
    css: estilo.css
---

# Materia

Consideremos una población finita compuesta por **N** unidades observadas, cada una de las observaciones pueden ser identificadas por una etiqueta, por lo cual el set esta definido por.

$$
U={1,...,N}
$$
<br>
Estamos interesados en la variable **y** la cual toma el valor de $y_k$ en la unidad $k$.Estos valores so nson aleatorios. El objetivo es estimar el valor de la función de interes.

$$
\vartheta=f(y_1,...,y_k,...,y_N)
$$
<br>

Las funciones de interes mas frecuentes son:

### Total
$$
Y=\sum_{k\in U}y_k
$$
<br>

### Media
$$
\bar{Y}=\frac{1}{N}\sum_{k\in U}y_k=\frac{Y}{N}
$$
<br>

### Varianza población
$$
\sigma_y^2=\frac{1}{N}\sum_{k\in U}{(y_k-\bar{Y})}^2
$$
<br>

### Varianza población corregida
$$
S_y^2=\frac{1}{N-1}\sum_{k\in U}{(y_k-\bar{Y})}^2
$$
<br>

Cuando observamos una pequeña parte de la población estamos inseguros sobre el parametro de la población estimado.
<br>

Utilizando metodos estaidsticos, podemos cuantificar cuan incierto es el resultado que obtuvimos.
<br>

Dos tipos de muestreo.

- **Aleatorio**: La probabilidad de seleccionar 1 unidad es conocida, muestreo aleatorio simple.
- **No aleatorio**: Muestreo conveniente, arbitrario o targeted.

<br>

Si tomamos a la población como real, conocemos los parametros de la población, Tambien para cada punto aleatorio de la población conocemos los valores, por lo que podemso estimar los parametros de la población.

La diferencia entre ellos es el error de muestreo en el parametro de la población.

Esto abre la posiblidad de repetir la seleccion aleatoria de muestra dado un diseño de muestreo una gran cantidad de veces. Estimadno el parametro de la población una gran cantidad de veces, obteniendo la frecuencia distribuida del parametro estimado de la población.

Idealmente las media de esta frecuencia distribuida es el parametro de la población(mean sampling error ewuals zero), y con una varianza pequeña.

## Arbitrary sampling v/s probability sampling

Es comun ver en publicaciones que aseveran que las muestras fueron seleccionadas aleatoriamente, sin mucha explicación de como fueron seleccionadas, dando paso a la posibilidad de que hayan seleccionado de forma arbitraria las muestras.

Con muestreo probabilistico, todas las unidades en la población tienen una probabilidad positiva de ser seleccionadas, y es conocidad para todas las observaciones.


## Metas de aprendizaje

al finalizar la ayudantía, ustedes podran...

1.  Estar familiarizado con la linea de trabajo de *R, Rstudio*.
2.  Ganar experiencia escribiendo un reporte reproducible utilizando *Rmarkdown*.
4.  Ganar experiencia analizando spatial-data.
3.  Ser capaz de crear visualizaciones utilizando `ggplot2`.
4.  Ser capaz de describir la distribución de una variable.
6.  Ser capaz de realizar un analisis descriptivo de una variable. 
5.  Ser capaz de realizar un muestreo aleatorio.


# Caso de estudio

Nuestra aréa de estudio pertenece a la Region del Maule en Chile, se tomo el perimetro completo como un MultiPolygon, se tomaron imagenes satelitales pertenecientes a la colección CHIRPS o Climate Hazards Group InfraRed Precipitation with Station Data es un quasi-global dataset de precipitaciones.
La cual toma imagenes satelitales en combinación con datos in-situ para crear grillas de precipitaciones para monitoreo.

El periodo de evaluación en este caso es comprende desde el 2017-07-01 al 2017-07-31.
Periodo en el cual nos encontramos en pleno invierno, lo cual es conveniente para nuestro analisis.

Se recolectaron 6 imagenes, las cuales fueron reducidas a 1, utilizando la función`ee.Reducer.Sum()`, obteniendo la siguiente imagen que vemos en el mapa.

## Mapa Precipitaciones Maule

```{r echo=FALSE, results='asis'}
cat('
<div style="display: flex; justify-content: center;">
  <div style="width: 80%; height: 100px;">
    ')
htmltools::includeHTML("oli.html")
cat('
  </div>
</div>
')
```
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>


Esta imagen se rasterizo y posteriormente se poligonizo para poder trabajarla.

## Packages

```{r,message=FALSE,warning=FALSE}
library(sf) #read spatial-data
library(tidyverse) #meta-package
library(gridExtra) #Graficos en conjunto
library(viridis) #Colores
library(RColorBrewer) #Colores 2
```

## Data-sets

Primero cargamos los data-sets que utilizaremos para nuestro analisis de las precipitaciones en la región del maule.

El primer data set, corresponde a una población discreta ya que estamos midiendo las precipitaciones en una aréa en particular en dos dimensiones(x,y), el cual procede de la rasterización y posterior poligonizacion de las aréas.

El segundo data set, corresponde a datos in-situ de las estaciones meteorologicas de la región del Maule, a las cuales se les aplico una interpolación mediante **IDW** con una distancia entre los puntos de 1km, se obtuvieron los valores predichos, por lo que esta población corresponderia a una discreta con dos dimensiones siendo estas las coordenadas (x,y).

```{r,warning=FALSE,message=FALSE}
datos_sf <- st_read("C:\\Users\\Diego\\Desktop\\Ayudantía Segundo Semestre\\Econometría\\Ayudantías\\Ayudantía_1\\lluvia_poly.shp") #
coords_maule <- read.csv("C:\\Users\\Diego\\Desktop\\Ayudantía Segundo Semestre\\Econometría\\Ayudantías\\Ayudantía_1\\coords_maule.csv")
```

## Diccionario de variables

### Dataset 1

| variable | class       | description                           |
|:---------|:------------|:--------------------------------------|
| lluvia   | integer     | Precipitaciones en mm                 |
|          |             |                                       |
| geometry | Polygon [m] | Geometría correspondiente al poligono |

### Dataset 2

| variable    | class  | description           |
|:------------|:-------|:----------------------|
| x           | double | Longitud              |
|             |        |                       |
| y           | double | Latitud               |
| z_predicted | double | Precipitaciones en mm |

## Revisemos los data-set

```{r}
head(coords_maule)
head(datos_sf)
```

```{r}
glimpse(coords_maule)
glimpse(datos_sf)
```

Todo parece correcto en nuestros datos, pero busquemos si es que existe algun valor faltante, para esto utilizaremos la función `summary(df)`, la cual nos entrega estadistica descriptiva de nuestro set de datos y tambien nos dice si hay valores faltantes.

```{r}
summary(coords_maule)
summary(datos_sf)
```

Todo parece correcto con nuestros set de datos, por lo que no tendremos que eliminar NA's.

## Grafiquemos nuestros datos :D

Partamos por *coords_maule*

```{r}
ggplot(data = coords_maule) +
  geom_raster(mapping = aes(x = x / 1000, y = y / 1000, fill = z_predicted)) +
  scale_x_continuous(name = "Longitud (km)") +
  scale_y_continuous(name = "Latitud (km)") +
  scale_fill_viridis_c(name = "Precipitacíon Lluvia en mm") +
  coord_fixed() +
  theme(panel.background = element_blank(),
        panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.background = element_blank()) + ggtitle("Precipitaciónes estimadas por IDW") 
```

Ahora el segundo

```{r}
ggplot() +
  geom_sf(data = datos_sf, aes(fill = lluvia)) +
  scale_fill_distiller(palette = "Blues", name = "Precipitaciones en mm", limits = c(min(datos_sf$lluvia),max(datos_sf$lluvia)),
                       direction = 1)+
  theme_minimal() +
  ggtitle("Raster precipitaciones Maule")
```

Hay zonas en las cuales en el mes de Julio precipito más que en otras, como podemos observar en ambos data sets, hay diferencias en ciertas zonas ya que tenemos que recordar que el primero corresponde a una interpolación y el segundo a los datos de las imagenes satelitales.

# Ejercicios

El objetivo es realizar una analisis descriptivo de nuestra variable de interes para ambos set de datos y posteriormente realizar un muestreo aleatorio para estimar ciertos estadisticos de interes.


## Ejercicio 1

Utilizando el df `coords_maule` grafique el histograma calculando el numero optimo de bins para eso considere la siguiente formula.
$$
h = 2 * IQR * n^{-1/3}
$$
<br>
$$
bins = (max-min)/h
$$
<br>

```{r}
Q1 <- quantile(coords_maule$z_predicted, probs =0.25, type = 6)[[1]]
Q3 <- quantile(coords_maule$z_predicted, probs =0.75,type = 6)[[1]]
IQR = Q3- Q1
h = 2*IQR*length(coords_maule$z_predicted)^(-1/3)
bins = (max(coords_maule$z_predicted)-min(coords_maule$z_predicted))/h
print(bins)
```
Aproximadamente 46 bins son los que debemos utilizar para deslpegar nuestro histograma.

Reemplace los valores en su Rmarkdown "___" para generar el histograma.

```{r,eval=FALSE}
ggplot("___", aes("___")) +
  geom_histogram(fill ="___", color = "___",) +
  labs(x = "___", y = "___") +
  theme_minimal() +
  ggtitle("___")
```



```{r,echo=FALSE,warning=FALSE,message=FALSE}
ggplot(coords_maule, aes(x = z_predicted)) +
  geom_histogram(fill = "steelblue", color = "black", bins = 46, alpha = 0.5) +
  labs(x = "LLuvia", y = "Frecuencia") +
  theme_minimal() +
  ggtitle("Histograma Datos LLuvia Maule")
```
<br>

Como es el comportamiento de las precipitaciónes, calcule la asimetría y la curtosis del histograma y concluya. Para eso debe utilizar el package `library(moments)`, si no lo tiene debe instalarlo con `install.packages("moments")`.

```{r,echo=FALSE,warning=FALSE}
library(moments)
skewness(coords_maule$z_predicted)
kurtosis(coords_maule$z_predicted)
```
La asimetría es de 0.58 lo que implica que tenemos una cola larga derecha y tiende a valores positivos y la kurtosis de 2,42 y una curtosis menor a 3 lo que implica que tengamos menos valores atipicosy outliers, pero eso lo podemos comprobar con un Boxplot


## Ejercicio 2

Genere un Boxplot de los datos con ggplot2.


```{r,eval=FALSE}
ggplot(data = "___", aes(x = "___", y = " ")) +
  stat_boxplot(geom = "errorbar",width = 0.5)+
  geom_boxplot(fill = "___",outlier.colour = "___", alpha = "___")
```



```{r,warning=FALSE,echo=FALSE, message=FALSE}
library(hrbrthemes)
ggplot(data = coords_maule, aes(x = z_predicted, y = " ")) +
  stat_boxplot(geom = "errorbar",width = 0.5)+
  geom_boxplot(fill = "#508c78",outlier.colour = "red", alpha = 0.9) +
  theme_ipsum() +
  ggtitle("Boxplot precipitaciones") 
```
<br>

Hay outliers?, que puede decir de la dispersión de los datos a través de la geometria.

## Ejercicio 3

Grafique la distribución de la variable de interes.


```{r,eval=FALSE}
ggplot("___", aes(x = "___")) + 
  geom_histogram(aes(y = ..density..), colour = "___", fill = "___", alpha = 0.2, bins="___")+
  geom_density(alpha = .2, fill = "___", colour = "___") 
```



```{r,warning=FALSE,echo=TRUE}
ggplot(coords_maule, aes(x = z_predicted)) + 
  geom_histogram(aes(y = ..density..), colour = "#3c78b4", fill = "#3c78b4", alpha = 0.2, bins=46)+
  geom_density(alpha = .4, fill = "#ffc8b4", colour = '#ffc8c8') +
  theme_minimal() + labs(title = "Densidad de las precipitaciones",
                         x="Precipitaciones",
                         y="Densidad")
```
<br>

Conclusiones?

## Ejercicio 4

Calcule la media, mediana, varianza y la varianza corregida de la población.

```{r,echo=FALSE}
print( paste("La media les deberia dar ",  round(mean(coords_maule$z_predicted))))
print( paste("La mediana les deberia dar ", round(median(coords_maule$z_predicted))))
var_cor <- sum((coords_maule$z_predicted - mean(coords_maule$z_predicted))^2) / (length(coords_maule$z_predicted) - 1)
var_norm<- sum((coords_maule$z_predicted - mean(coords_maule$z_predicted))^2) / (length(coords_maule$z_predicted))
print(paste("La varianza de la población",round(var_norm,2)))
print(paste("La varianza de la población corregida",round(var_cor,2)))

```
## Ejercicio 5

Para este estudio se realizara un muestreo aleatorio simple de tamaño 110 sin reemplazo.

```{r}
n <- 110
N <- nrow(coords_maule)
set.seed(707)
units <- sample(N, size = n, replace = FALSE)
mysample1 <- coords_maule[units, ]
head(mysample1)
```

```{r}
ggplot(coords_maule, mapping = aes(x =  x/ 1000, y =  y/ 1000)) +
  geom_raster(fill = "grey") +
  geom_point(data = mysample1, size = 1.5) +
  scale_x_continuous(name = "Longitud (km)") +
  scale_y_continuous(name = "Latitud (km)") +
  coord_fixed() +
  theme(legend.position = "none") +
  theme(panel.background = element_blank(),
        panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.background = element_blank()) +ggtitle("Muestreo aleatorio simple de Precipitaciones Maule")
```

El resultado de la función `sample()` es un vector con las observaciones seleccionadas de la grilla, el orden de ellos es en el cual fueron seleccionados de la población.


```{r}
set.seed(707)
units <- sample(N, size = n, replace = TRUE)
mysample <- coords_maule[units, ]
cellsize <- 100
mysample$s1 <- jitter(mysample$s1, amount = cellsize / 2)
mysample$s2 <- jitter(mysample$s2, amount = cellsize / 2)
head(mysample)
```

```{r}
ggplot(coords_maule, mapping = aes(x =  x/ 1000, y =  y/ 1000)) +
  geom_raster(fill = "grey") +
  geom_point(data = mysample, size = 1.5) +
  scale_x_continuous(name = "Longitud (km)") +
  scale_y_continuous(name = "Latitud (km)") +
  coord_fixed() +
  theme(legend.position = "none") +
  theme(panel.background = element_blank(),
        panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.background = element_blank()) +ggtitle("Muestreo aleatorio simple de Precipitaciones Maule")
```
<br>

Calcule la media para la estimación

```{r}
mz <- mean(mysample1$z_predicted)
mz
```



## Ejercicio 6

Que ocurre si la población ahora es sampleada 10.000 veces, como afecta la estimación de la media, realice un iterador para calcular la media para todas las muestras, luego grafique un histograma agregandole la distribución de la variable, luego calcule la media para todas las muestras:

```{r,echo=FALSE,warning=FALSE}
n <- 110
n_samples <- 10000

mz <- v_mz <- numeric(length = n_samples)
N <- nrow(coords_maule)

set.seed(707)

for (i in 1:n_samples) {
  units <- sample(N, size = n, replace = TRUE)
  mz[i] <- mean(coords_maule$z_predicted[units])
  v_mz[i] <- var(coords_maule$z_predicted[units]) / n
}
mz_df <- data.frame(mz = mz)
ggplot(mz_df) +
  geom_histogram(aes(x = mz, y = ..density..), binwidth = 2, fill = "#40b16d", alpha = 0.5, colour = "black") +
  geom_density(aes(x = mz, y = ..density..), lwd = 1) +
  scale_x_continuous(name = "Media Estimada Precipitaciones") +
  scale_y_continuous(name = "Density")
```

## Ejercicio 7

Sea $X_1, X_2, ..., X_n$ un muestreo aleatorio de tamaño $n$ proviniente de una distribución con media $µ$ y varianza $\sigma^2$.

1. Demuestre que $E\left(\bar{x}\right)=\mu$.
2. ¿Cual es la varianza de $\bar{X}$?.


Compruebe ahora utilizando los datos anteriores, que puede concluir.

## Ejercicio 8

Calcule el error estandar de la media estimada de la población, utilizando la siguiente formula.

```{r,eval=FALSE}
se_mean <- sqrt(var("____")/"_____")

```

## Ejercicio 9

Una segunda manera de expresar la incerteza sobre el valor estimado es presentar un intervalo, mientras mas largo el intervalo mas incerteza tenemos sobre la estimación y viceversa.

Supongamos que queremos calcular los limites de un intervalo $[a,b]$ tal que el 5\% de la estimación de la media sea menor que $a$ y 5\% mayor que $b$. Para calcular el limite inferior $a$ y el superior $b$ de este intervalo del 90\%, debemos especificar la función de distribución. 

Cuando la distribución de nuestra variable de estudio es normal y conocemos la varianza de la población, entonces la distribución de la muestra tambien sera normal.

Mientras mas largo sea el tamaño de la muestra, menor el efecto de la distribución de z en la distribución de la muestra estimada de la media de la población.

Inclusive si la distribución de la variable no es simetrica, la distribucion de la muestra estimada de la media es aproximadamente normal mientras mas aumente el tamaño de la muestra, digamos $n>100$. En escencia esto es la base del teorema del limite central.

Asumiendo una distribución normal, los limites de nuestro intervalo de confianza seran.

$$
\widehat{\bar{z}}\pm u_{(0.10/2)}\ast\sqrt{V(\widehat{\bar{z}})}
$$
La media de la población no es una variable aleatoria, por ende la probabilidad de que la media de la población este en el intervalo no existe.

los limites estimados si son variables aleatorias, ya que las medias estimadas varian dependiendo de la muestra de la cual fueron estimadas, y estas muestras provienen de un diseño probabilistico.

Por lo tanto, si hace sentido que le calculemos una probabilidad al intervalo de confianza.

```{r,echo=FALSE}
se_mz <- sqrt(var(mysample$z_predicted) / n)
alpha <- 0.05
margin <- qt(1 - alpha / 2, n - 1, lower.tail = TRUE) * se_mz
lower <- mz - margin
upper <- mz + margin
```

```{r,echo=FALSE}
lower <- mz - qt(0.05, n -1 , lower.tail = FALSE) * sqrt(v_mz)
upper <- mz + qt(0.05, n -1, lower.tail = FALSE) * sqrt(v_mz)
mz_pop <- mean(coords_maule$z_predicted)
ind <- (mz_pop > lower & mz_pop < upper)
coverage <- mean(ind)
x <- c(lower[1:100], upper[1:100])
y <- rep(seq_along(lower[1:100]), times = 2)
ind_group = ifelse(ind[1:100], "Contiene la media", "No contiene la Media")
id <- y
df <- data.frame(id, x, y,ind_group)
ggplot(data = df) +
        geom_path(mapping = aes(x = x, y = y,group = id,color = ind_group)) +
        scale_x_continuous(name = "Intervalo de 90% de la media") +
        scale_y_continuous(name = "Sample\n", limits = c(0, 100)) +
        geom_vline(xintercept = mz_pop, colour = "black")

```
<br>

de 10.000 muestras, 976 no contienen la media poblacional, bastante cercano al valor especificado de 10%. Por ende, un intervalo de confianza de 90% es un intervalo aleatorio que contiene en un 90% de las veces el parametro de la población.

¡Eso fue todo por esta semana nos vemos la proxima!


